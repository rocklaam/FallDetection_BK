////opencv
//#include "opencv2/imgcodecs.hpp"
//#include "opencv2/imgproc.hpp"
//#include "opencv2/videoio.hpp"
//#include <opencv2/highgui.hpp>
//#include <opencv2/video.hpp>
//#include "opencv2/features2d.hpp"
//#include "opencv2\core\core.hpp";
////C
//#include <stdio.h>
////C++
//#include <iostream>
//#include <sstream>
//
//using namespace cv;
//using namespace std;
//
//// Global variables
//Mat frame, resize_blur_Img; //current frame
//Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
//Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
//int keyboard; //input from keyboard
//void help();
//void processVideo(char* videoFilename);
//void processImages(char* firstFrameFilename);
//void help()
//{
//	cout
//		<< "--------------------------------------------------------------------------" << endl
//		<< "This program shows how to use background subtraction methods provided by " << endl
//		<< " OpenCV. You can process both videos (-vid) and images (-img)." << endl
//		<< endl
//		<< "Usage:" << endl
//		<< "./bs {-vid <video filename>|-img <image filename>}" << endl
//		<< "for example: ./bs -vid video.avi" << endl
//		<< "or: ./bs -img /data/images/1.png" << endl
//		<< "--------------------------------------------------------------------------" << endl
//		<< endl;
//}
//int main()
//{
//	//print help information
//	help();
//	//check for the input parameter correctness
//
//	//create GUI windows
//	namedWindow("Frame");
//	namedWindow("FG Mask MOG 2");
//	//create Background Subtractor objects
//	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
//
//	processVideo("E:/BachKhoaUni/DoAn/ThesisProject_2018/FallDetection_BK/Private/Office/a.avi");
//	//processImages("demo.jpg");
//
//	//destroy GUI windows
//	waitKey(0);
//	return 1;
//}
//void processVideo(char* videoFilename) {
//	Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
//	//create the capture object
//	VideoCapture capture(0);
//	if (!capture.isOpened()){
//		//error in opening the video input
//		cerr << "Unable to open video file: " << videoFilename << endl;
//		exit(EXIT_FAILURE);
//	}
//	//read input data. ESC or 'q' for quitting
//	while ((char)keyboard != 'q' && (char)keyboard != 27){
//		//read the current frame
//		if (!capture.read(frame)) {
//			cerr << "Unable to read next frame." << endl;
//			cerr << "Exiting..." << endl;
//			exit(EXIT_FAILURE);
//		}
//		//Resize
//		resize(frame, resize_blur_Img, Size(frame.size().width / 3, frame.size().height / 3));
//		//Blur
//		blur(resize_blur_Img, resize_blur_Img, Size(4, 4));
//		cvtColor(resize_blur_Img, resize_blur_Img, COLOR_BGR2GRAY);
//		equalizeHist(resize_blur_Img, resize_blur_Img);
//		//update the background model
//		pMOG2->apply(resize_blur_Img, fgMaskMOG2);
//		morphologyEx(fgMaskMOG2, fgMaskMOG2, CV_MOP_CLOSE, element);
//		threshold(fgMaskMOG2, fgMaskMOG2, 128, 255, CV_THRESH_BINARY);
//		vector <vector<Point>> contours;
//		vector<Vec4i> hierarchy;
//		if (fgMaskMOG2.type() == CV_8UC1&& fgMaskMOG2.rows > 0){
//			cout << "I love Hang!!!" << endl;
//			findContours(fgMaskMOG2, contours, hierarchy, RETR_TREE, CV_CHAIN_APPROX_NONE);
//		}
//		Mat contoursMat = Mat::zeros(fgMaskMOG2.size(), CV_8UC3);
//		for (size_t i = 0; i < contours.size(); i++){
//			Scalar color = Scalar(255, 255, 255);
//			drawContours(contoursMat, contours, (int)i, color);
//		}
//		imshow("contours", contoursMat);
//		imshow("Frame", frame);
//		imshow("FG Mask MOG 2", fgMaskMOG2);
//		//get the input from the keyboard
//		keyboard = waitKey(30);
//	}
//	//delete capture object
//	capture.release();
//}
//void processImages(char* fistFrameFilename) {
//	//read the first file of the sequence
//	frame = imread(fistFrameFilename);
//	if (frame.empty()){
//		//error in opening the first image
//		cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
//		exit(EXIT_FAILURE);
//	}
//	//current image filename
//	string fn(fistFrameFilename);
//	//read input data. ESC or 'q' for quitting
//	while ((char)keyboard != 'q' && (char)keyboard != 27){
//		//update the background model
//		pMOG2->apply(frame, fgMaskMOG2);
//		//get the frame number and write it on the current frame
//		size_t index = fn.find_last_of("/");
//		if (index == string::npos) {
//			index = fn.find_last_of("\\");
//		}
//		size_t index2 = fn.find_last_of(".");
//		string prefix = fn.substr(0, index + 1);
//		string suffix = fn.substr(index2);
//		string frameNumberString = fn.substr(index + 1, index2 - index - 1);
//		istringstream iss(frameNumberString);
//		int frameNumber = 0;
//		iss >> frameNumber;
//		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
//			cv::Scalar(255, 255, 255), -1);
//		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
//			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
//		//show the current frame and the fg masks
//		imshow("Frame", frame);
//		imshow("FG Mask MOG 2", fgMaskMOG2);
//		//get the input from the keyboard
//		keyboard = waitKey(30);
//		//search for the next image in the sequence
//		ostringstream oss;
//		oss << (frameNumber + 1);
//		string nextFrameNumberString = oss.str();
//		string nextFrameFilename = prefix + nextFrameNumberString + suffix;
//		//read the next frame
//		frame = imread(nextFrameFilename);
//		if (frame.empty()){
//			//error in opening the next image in the sequence
//			cerr << "Unable to open image frame: " << nextFrameFilename << endl;
//			exit(EXIT_FAILURE);
//		}
//		//update the path of the current frame
//		fn.assign(nextFrameFilename);
//	}
//}
//
//////stub for blob detection
////Mat im = imread("2.jpg", IMREAD_GRAYSCALE);
////imshow("original", im);
////// Set up the detector with default parameters.
//////SimpleBlobDetector detector;
////Ptr<SimpleBlobDetector> detector = SimpleBlobDetector::create();
////// Detect blobs.
////std::vector<KeyPoint> keypoints;
////detector->detect(im, keypoints);
////cout << keypoints.size() << endl;
////cout << keypoints[0].pt << endl;
//////// Draw detected blobs as red circles.
//////// DrawMatchesFlags::DRAW_RICH_KEYPOINTS flag ensures the size of the circle corresponds to the size of blob
////Mat im_with_keypoints;
////drawKeypoints(im, keypoints, im_with_keypoints);
////////cvtColor(im_with_keypoints, im_with_keypoints, CV_GRAY2RGB);
////
////// Show blobs
////imshow("keypoints", im_with_keypoints);
//
//
////#ifdef _DEBUG        
////#pragma comment(lib, "opencv_core300d.lib")
////#pragma comment(lib, "opencv_imgproc300d.lib")   //MAT processing
////#pragma comment(lib, "opencv_objdetect300d.lib") //HOGDescriptor
//////#pragma comment(lib, "opencv_gpu300d.lib")
//////#pragma comment(lib, "opencv_features2d300d.lib")
////#pragma comment(lib, "opencv_highgui300d.lib")
////#pragma comment(lib, "opencv_ml300d.lib")
//////#pragma comment(lib, "opencv_stitching300d.lib");
//////#pragma comment(lib, "opencv_nonfree300d.lib");
////#pragma comment(lib, "opencv_video300d.lib")
////#else
////#pragma comment(lib, "opencv_core300.lib")
////#pragma comment(lib, "opencv_imgproc300.lib")
////#pragma comment(lib, "opencv_objdetect300.lib")
//////#pragma comment(lib, "opencv_gpu300.lib")
//////#pragma comment(lib, "opencv_features2d300.lib")
////#pragma comment(lib, "opencv_highgui300.lib")
////#pragma comment(lib, "opencv_ml300.lib")
//////#pragma comment(lib, "opencv_stitching300.lib");
//////#pragma comment(lib, "opencv_nonfree300.lib");
////#pragma comment(lib, "opencv_video300d.lib")
////#endif 
////
////
////#include "opencv2/highgui.hpp"
////#include "opencv2/imgproc.hpp"
////#include <iostream>
////#include <stdio.h>
////#include <stdlib.h>
////
////using namespace cv;
////using namespace std;
////
////Mat src; Mat src_gray;
////int thresh = 100;
////int max_thresh = 255;
////RNG rng(12345);
////
/////// Function header
////void thresh_callback(int, void*);
////
/////** @function main */
////int main(int argc, char** argv)
////{
////	/// Load source image and convert it to gray
////	src = imread("blob.jpg");
////
////	/// Convert image to gray and blur it
////	cvtColor(src, src_gray, COLOR_BGR2GRAY);
////	blur(src_gray, src_gray, Size(3, 3));
////
////	/// Create Window
////	char* source_window = "Source";
////	namedWindow(source_window, WINDOW_AUTOSIZE);
////	imshow(source_window, src);
////
////	createTrackbar(" Canny thresh:", "Source", &thresh, max_thresh, thresh_callback);
////	thresh_callback(0, 0);
////
////	waitKey(0);
////	return(0);
////}
////
/////** @function thresh_callback */
////void thresh_callback(int, void*)
////{
////	Mat canny_output;
////	vector<vector<Point> > contours;
////	vector<Vec4i> hierarchy;
////
////	/// Detect edges using canny
////	Canny(src_gray, canny_output, thresh, thresh * 2, 3);
////	//cout << canny_output;
////	/// Find contours
////	findContours(canny_output, contours, RETR_LIST, CHAIN_APPROX_SIMPLE, Point(0, 0));
////
////	/// Draw contours
////	Mat drawing = Mat::zeros(canny_output.size(), CV_8UC3);
////	for (int i = 0; i < contours.size(); i++)
////	{
////		Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
////		drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, Point());
////	}
////
////	/// Show in a window
////	namedWindow("Contours", WINDOW_AUTOSIZE);
////	imshow("Contours", drawing);
////}