//#include "CurlUtils.h"
//#include "Config.h"
//#include "MHIProcess.h"
//
//#include <stdio.h>
//#include <iostream>
//
//#include <opencv2/optflow.hpp>
//#include <opencv2/opencv.hpp>
//#include <opencv2/core/core.hpp>
//#include <opencv2/highgui/highgui.hpp>
//
//using namespace cv;
//using namespace std;
//using namespace cv::motempl;
//
//// ring image buffer
//vector<Mat> buf;
//int last = 0;
//Mat mhi;
//
//static void  update_mhi(const Mat& img, Mat& dst, int diff_threshold, double& sumHist)
//{
//	double timestamp = (double)clock() / CLOCKS_PER_SEC; // get current time in seconds
//	Size size = img.size();
//	int idx1 = last;
//	Rect comp_rect;
//	// allocate images at the beginning or
//	// reallocate them if the frame size is changed
//	if (mhi.size() != size)
//	{
//		mhi = Mat::zeros(size, CV_32F);
//
//		buf[0] = Mat::zeros(size, CV_8U);
//		buf[1] = Mat::zeros(size, CV_8U);
//	}
//
//	cvtColor(img, buf[last], COLOR_BGR2GRAY); // convert frame to grayscale
//	//buf[last] = img;
//
//	int idx2 = (last + 1) % 2; // index of (last - (N-1))th frame
//	last = idx2;
//
//	Mat silh = buf[idx2];
//	absdiff(buf[idx1], buf[idx2], silh); // get difference between frames
//
//	threshold(silh, silh, diff_threshold, 1, THRESH_BINARY); // and threshold it
//	updateMotionHistory(silh, mhi, timestamp, MHI_DURATION); // update MHI
//	mhi.convertTo(dst, CV_8U, 255. / MHI_DURATION, (MHI_DURATION - timestamp)*255. / MHI_DURATION);
//	// Calculata sumHist
//	for (int i = 0; i < dst.rows; i++){
//		for (int j = 0; j < dst.cols; j++){
//			sumHist += (float)(dst.at<uchar>(i, j) / 255);
//		}
//	}
//	cout << sumHist << endl;
//	////clear the screen
//	//system("cls");
//	// convert MHI to 8u image	
//}
//
//int main()
//{
//	//global variables
//	Mat frame; //current frame
//	Mat resize_blur_Img;
//	Mat binaryImg;
//	Mat mhi_dst;    // mhi image;
//	bool isFall = false;
//	//Mat TestImg;
//	Mat ContourImg; //fg mask fg mask generated by MOG2 method
//	Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
//	buf.resize(2); //init for buffer images array
//
//	pMOG2 = cv::createBackgroundSubtractorMOG2(300, 32, true);//300,0.0);
//	//pMOG2 = cv::createBackgroundSubtractorMOG2(60, 15, true);
//
//
//	//char fileName[100] = "E:/BachKhoaUni/DoAn/ThesisProject_2018/FallDetection_BK/Private/Office/video (5).avi";
//	////video\\mm2.avi"; //mm2.avi"; //cctv 2.mov"; //mm2.avi"; //";//_p1.avi";
//	//VideoCapture stream1(0);   //0 is the id of video device.0 if you have only one camera   
//
//	//morphology element
//	//Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
//	Mat element(16, 16, CV_8U, cv::Scalar(1));
//	Scalar color(0, 255, 0);
//
//	//unconditional loop   
//	while (true) {
//		double sumHist = 0;
//		//if (!(stream1.read(frame))) //get one frame form video   
//		//	break;
//		//frame = curlImg("http://192.168.0.222:8888/snapshot.cgi?loginuse=admin&loginpas=admin");
//		//if (!CurlUtils::curlImg("http://192.168.0.222:8888/snapshot.cgi?loginuse=admin&loginpas=admin", frame))
//		if (!CurlUtils::curlImg("http://27.2.173.142:8888/snapshot.cgi?loginuse=admin&loginpas=admin", frame))
//		{
//			continue;
//		}
//
//		//Resize
//		resize(frame, resize_blur_Img, Size(frame.size().width / 2, frame.size().height / 2)); /*IP-Cam:2 in height, 0: 2.7 in ground test*/
//		//resize_blur_Img = frame.clone();
//		//Blur
//		blur(resize_blur_Img, resize_blur_Img, Size(4, 4));
//		//cvtColor(resize_blur_Img, resize_blur_Img, COLOR_BGR2GRAY);
//		//equalizeHist(resize_blur_Img, resize_blur_Img);
//		//Background subtraction
//		pMOG2->apply(resize_blur_Img, binaryImg, -1);//,-0.5);
//		//MHIProcess::updateMHI(resize_blur_Img, mhi_dst, 30, sumHist);
//		update_mhi(resize_blur_Img, mhi_dst, 30, sumHist);
//
//		///////////////////////////////////////////////////////////////////
//		//pre procesing
//
//		//1 point delete
//		//morphologyEx(fgMaskMOG2, fgMaskMOG2, CV_MOP_ERODE, element);
//		morphologyEx(binaryImg, binaryImg, CV_MOP_CLOSE, element);
//		//morphologyEx(fgMaskMOG2, testImg, CV_MOP_OPEN, element);
//
//		//Shadow delete
//		//Binary
//		threshold(binaryImg, binaryImg, 128, 255, CV_THRESH_BINARY);
//		//threshold(binaryImg, binaryImg, 70.0f, 255, CV_THRESH_BINARY);
//
//		//Find contour
//		ContourImg = binaryImg.clone();
//		//less blob delete
//		vector< vector< Point> > contours;
//		findContours(ContourImg,
//			contours, // a vector of contours
//			CV_RETR_EXTERNAL, // retrieve the external contours
//			CV_CHAIN_APPROX_NONE); // all pixels of each contours
//
//		if (contours.size() > 0){
//			double theLargestArea = 0;
//			int theLargestIndex = 0;
//			for (int i = 1; i < contours.size(); i++){
//				int a = boundingRect(contours[i]).area();
//				if (a > theLargestArea && a >= 3000){ /*IP-Cam: 7000, 0:6000 on the ground test*/
//					theLargestArea = a;
//					theLargestIndex = i;
//				}
//			}
//			//cout << theLargestArea << endl;
//			//bouding rect
//			rectangle(resize_blur_Img, boundingRect(contours[theLargestIndex]), color, 4);
//			//fit elipse
//			//try{
//			//	RotatedRect rotatedRect = fitEllipse((Mat)contours[theLargestIndex]);
//			//	//cout << rotatedRect.angle << "+ "<<rotatedRect.size.width;
//			//	//cout << (rotatedRect.size.width - rotatedRect.size.height) / 2 << endl;
//			//	ellipse(resize_blur_Img, rotatedRect, color);
//			//	//ellipse(resize_blur_Img, rotatedRect.center, rotatedRect.size*0.5f, rotatedRect.angle, 0, 360, Scalar(0, 255, 255));
//			//}
//			//catch (Exception e){}
//			if (theLargestArea > 0){
//				double firstNum = sumHist / (contourArea(contours[theLargestIndex]) * 255);
//				//cout << firstNum << endl;
//				if (firstNum > 2){
//					cout << "\a" << endl;
//					//cout << "FALL" << endl;
//					//cout << firstNum << endl;
//					//color = Scalar(0, 0, 255);
//					isFall = true;
//				}
//			}
//		}
//
//		///////////////////////////////////////////////////////////////////
//
//		//Display
//		imshow("Shadow_Removed", binaryImg);
//		imshow("Blur_Resize", resize_blur_Img);
//		imshow("MHI", mhi_dst);
//
//		if (waitKey(5) >= 0)
//			break;
//	}
//
//}