#include <curl/curl.h>
#include <stdio.h>
#include <iostream>
#include <opencv2/optflow.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>

using namespace cv;
using namespace std;
using namespace cv::motempl;

const double MHI_DURATION = 0.5;
// ring image buffer
vector<Mat> buf;
int last = 0;
Mat mhi;

size_t write_data(char *ptr, size_t size, size_t nmemb, void *userdata)
{
	vector<uchar> *stream = (vector<uchar>*)userdata;
	size_t count = size * nmemb;
	stream->insert(stream->end(), ptr, ptr + count);
	return count;
}

Mat curlImg(const char *img_url, int timeout = 10)
{
	vector<uchar> stream;
	CURL *curl = curl_easy_init();
	curl_easy_setopt(curl, CURLOPT_URL, img_url); //the img url
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data); // pass the writefunction
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &stream); // pass the stream ptr to the writefunction
	curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout); // timeout if curl_easy hangs, 
	struct curl_slist *hs = NULL;
	hs = curl_slist_append(hs, "Content-Type: image/jpeg");
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, hs);
	CURLcode res = curl_easy_perform(curl); // start curl
	curl_easy_cleanup(curl); // cleanup
	return imdecode(stream, -1); // 'keep-as-is'
}

static void  update_mhi(const Mat& img, Mat& dst, int diff_threshold, double& sumHist)
{
	double timestamp = (double)clock() / CLOCKS_PER_SEC; // get current time in seconds
	//cout << timestamp << endl;
	Size size = img.size();
	int idx1 = last;
	Rect comp_rect;

	// allocate images at the beginning or
	// reallocate them if the frame size is changed
	if (mhi.size() != size)
	{
		mhi = Mat::zeros(size, CV_32F);

		buf[0] = Mat::zeros(size, CV_8U);
		buf[1] = Mat::zeros(size, CV_8U);
	}

	cvtColor(img, buf[last], COLOR_BGR2GRAY); // convert frame to grayscale
	//buf[last] = img;

	int idx2 = (last + 1) % 2; // index of (last - (N-1))th frame
	last = idx2;

	Mat silh = buf[idx2];
	absdiff(buf[idx1], buf[idx2], silh); // get difference between frames

	threshold(silh, silh, diff_threshold, 1, THRESH_BINARY); // and threshold it
	updateMotionHistory(silh, mhi, timestamp, MHI_DURATION); // update MHI
	mhi.convertTo(dst, CV_8U, 255. / MHI_DURATION, (MHI_DURATION - timestamp)*255. / MHI_DURATION);
	// Calculata sumHist
	for (int i = 0; i < dst.rows; i++){
		for (int j = 0; j < dst.cols; j++){
			sumHist += dst.at<uchar>(i, j);
		}
	}
	// convert MHI to 8u image	
}

int main()
{

	//global variables
	Mat frame; //current frame
	Mat resize_blur_Img;
	Mat binaryImg;
	Mat mhi_dst;    // mhi image;
	//Mat TestImg;
	Mat ContourImg; //fg mask fg mask generated by MOG2 method
	Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
	buf.resize(2); //init for buffer images array

	pMOG2 = cv::createBackgroundSubtractorMOG2(300, 32, true);//300,0.0);

	//char fileName[100] = "E:/BachKhoaUni/DoAn/ThesisProject_2018/FallDetection_BK/Private/Office/video (5).avi";
	////video\\mm2.avi"; //mm2.avi"; //cctv 2.mov"; //mm2.avi"; //";//_p1.avi";
	//VideoCapture stream1(0);   //0 is the id of video device.0 if you have only one camera   

	//morphology element
	Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
	//Mat element(16, 16, CV_8U, cv::Scalar(1));
	Scalar color(0, 255, 0);

	//unconditional loop   
	while (true) {
		double sumHist = 0;
		//if (!(stream1.read(frame))) //get one frame form video   
		//	break;
		frame = curlImg("http://192.168.0.222:8888/snapshot.cgi?loginuse=admin&loginpas=admin");

		//Resize
		resize(frame, resize_blur_Img, Size(frame.size().width / 3, frame.size().height / 3));
		//Blur
		blur(resize_blur_Img, resize_blur_Img, Size(4, 4));
		update_mhi(resize_blur_Img, mhi_dst, 30, sumHist);
		//cvtColor(resize_blur_Img, resize_blur_Img, COLOR_BGR2GRAY);
		//equalizeHist(resize_blur_Img, resize_blur_Img);
		//Background subtraction
		pMOG2->apply(resize_blur_Img, binaryImg, -1);//,-0.5);

		///////////////////////////////////////////////////////////////////
		//pre procesing

		//1 point delete
		//morphologyEx(fgMaskMOG2, fgMaskMOG2, CV_MOP_ERODE, element);
		morphologyEx(binaryImg, binaryImg, CV_MOP_CLOSE, element);
		//morphologyEx(fgMaskMOG2, testImg, CV_MOP_OPEN, element);

		//Shadow delete
		//Binary
		threshold(binaryImg, binaryImg, 128, 255, CV_THRESH_BINARY);

		//Find contour
		ContourImg = binaryImg.clone();
		//less blob delete
		vector< vector< Point> > contours;
		findContours(ContourImg,
			contours, // a vector of contours
			CV_RETR_EXTERNAL, // retrieve the external contours
			CV_CHAIN_APPROX_NONE); // all pixels of each contours

		if (contours.size() > 0){
			double theLargestArea = 0;
			int theLargestIndex = 0;
			for (int i = 1; i < contours.size(); i++){
				int a = boundingRect(contours[i]).area();
				if (a > theLargestArea && a >= 6000){
					theLargestArea = a;
					theLargestIndex = i;
				}
			}
			cout << theLargestArea << endl;
			// bouding rect
			rectangle(resize_blur_Img, boundingRect(contours[theLargestIndex]), color);
			// fit elipse
			try{
				RotatedRect rotatedRect = fitEllipse((Mat)contours[theLargestIndex]);
				//cout << rotatedRect.angle << "+ "<<rotatedRect.size.width;
				//cout << (rotatedRect.size.width - rotatedRect.size.height) / 2 << endl;
				ellipse(resize_blur_Img, rotatedRect, color);
				//ellipse(resize_blur_Img, rotatedRect.center, rotatedRect.size*0.5f, rotatedRect.angle, 0, 360, Scalar(0, 255, 255));
			}
			catch (Exception e){}
			if (theLargestArea > 0){
				double firstNum = sumHist / (contourArea(contours[theLargestIndex]) * 255);
				//cout << theLargestArea << endl;
				if (firstNum > 1.1){
					cout << "FALL" << endl;
					//cout << firstNum << endl;
					color = Scalar(0, 0, 255);
				}
			}
		}

		///////////////////////////////////////////////////////////////////

		//Display
		imshow("Shadow_Removed", binaryImg);
		imshow("Blur_Resize", resize_blur_Img);
		imshow("MHI", mhi_dst);

		if (waitKey(5) >= 0)
			break;
	}

}