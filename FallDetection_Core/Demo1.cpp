#include "CurlUtils.h"
#include "MHIProcess.h"

#include <iostream>

bool _calElipseParams(RotatedRect &rotatedRect, vector<Point> contour, float &angle, float &a_b)
{
	try
	{
		rotatedRect = fitEllipse((Mat)contour);
		// Calculate angle
		angle = rotatedRect.angle;
		if (angle > 90)
		{
			angle = angle - 180;
		}
		a_b = rotatedRect.size.height / rotatedRect.size.width;
		return true;
	}
	catch (Exception e)
	{
		return false;
	}
}


int main()
{
	//// demo curl notification in firebase
	//char data[] = "{\"to\":\"deBbaMW5K6U:APA91bHp12vN-nWDcn6D5c0AV7SLK7VbGHtYMyL1NmJfN5yAcJm7HNuV5ivWQqAnfl_9ls7o99wR_hnzUii8HdnULCv6WCSm4xhnNVfj-9B00LLv2jwyC65k5YxdIqaByduyxUxLWk3S\",\"data\":{\"notification\":{\"body\":\"Are you coming to our party?\",\"title\":\"This is a tester tester\"}}}";
	//struct curl_slist *hs = NULL;
	//hs = curl_slist_append(hs, "Authorization: key = AIzaSyAMBEmcJ - TMH0vhyDgd0yeG - hbeW6xYCeY");
	//hs = curl_slist_append(hs, "Content-Type:application/json");
	//CurlUtils::curlURLWithData("http://fcm.googleapis.com/fcm/send", hs, data);

	// variables
	float a_b0 = 0;								// params of ellipse to calculate d0 and dA_B
	float angle0 = 0;
	float stageTime0;							// the starting time for each stage, to calculate dT
	float humanArea = 0;						// param to recog the last area of human after fall
	float a_b1, angle1, timeStamp;
	int stage = STAGE_CMOTION;					// stage of algorithm
	Mat binaryImg;								// foreground mask fg mask generated by MOG2 method
	Mat contourImg;
	Mat frame;									// current frame
	Mat mhiDst;									// mhi image;
	Mat element(16, 16, CV_8U, cv::Scalar(1));	// morphology element
	Point2f center0(0, 0);						// point to regconize to last center of body after fall
	Point2f center1(0, 0);
	// MOG2 Background subtractor
	Ptr< BackgroundSubtractor> pMOG2 = cv::createBackgroundSubtractorMOG2(300, 32, true);
	Scalar color(0, 255, 0);					// color
	RotatedRect rotatedRect;					// rectangle to determine elipse


	// Detect fall- unconditional loop
	while (true) {
		// Curl Image;
		if (!CurlUtils::curlImg("http://192.168.0.222:8888/snapshot.cgi?loginuse=admin&loginpas=admin", frame))
			//if (!CurlUtils::curlImg("http://27.2.173.142:8888/snapshot.cgi?loginuse=admin&loginpas=admin", frame))
		{
			continue;
		}

		// Pre procesing- Resize
		resize(frame, frame, Size(FRAME_WIDTH, FRAME_HEIGHT));
		// Blur
		blur(frame, frame, Size(4, 4));

		// Background subtraction
		pMOG2->apply(frame, binaryImg, -1);//,-0.5);
		// Calculate MHI
		float sumHist = 0;
		MHIProcess::updateMHI(frame, mhiDst, 30, sumHist);

		// Process for foreground image- Delete 1 point
		morphologyEx(binaryImg, binaryImg, CV_MOP_CLOSE, element);
		// Shadow Delete Shadow
		threshold(binaryImg, binaryImg, 128, 255, CV_THRESH_BINARY);

		// Find contour- Retrieve the external contours, all pixels of each contours
		vector< vector< Point> > contours;
		contourImg = binaryImg.clone();
		findContours(contourImg, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);

		// Detect fall based on contours
		if (contours.size() > 0)
		{
			// Detect human by area of contour
			int theLargestId = 0;
			int theLargestRect = 0;
			for (int i = 0; i < contours.size(); i++)
			{
				int a = boundingRect(contours[i]).area();
				if (a > theLargestRect && a >= 3000 && contours[i].size() > 5)
				{
					theLargestId = i;
					theLargestRect = a;
				}
			}
			if (theLargestRect > AREA_MAX)
			{
				theLargestRect = 0;
			}
			if (theLargestRect > 0 || stage == STAGE_DY)	// Found a human in frame
			{
				switch (stage)
				{
				case STAGE_CMOTION:
					// Drawing bouding rect
					rectangle(frame, boundingRect(contours[theLargestId]), color, 4);
					// Calculate cMotion= sumHist / (contourArea(contours[theLargestId]))
					if (sumHist / (contourArea(contours[theLargestId])) > THRESHOLD_CMOTION){
						if (!_calElipseParams(rotatedRect, contours[theLargestId], angle0, a_b0))
						{
							continue;
						}
						stageTime0 = (float)clock() / CLOCKS_PER_SEC;
						stage = STAGE_D0;
					}
					break;
				case STAGE_D0:
					if (_calElipseParams(rotatedRect, contours[theLargestId], angle1, a_b1))
					{
						ellipse(frame, rotatedRect, color, 4); // Drawing bouding rect
						if (abs(angle1 - angle0) > THRESHOLD_D0 || abs(a_b0 - a_b1) > THRESHOLD_DA_B)
						{
							//center0 = rotatedRect.center;
							stageTime0 = (float)clock() / CLOCKS_PER_SEC;
							humanArea = contourArea(contours[theLargestId]);
							stage = STAGE_DY;
							continue;
						}
					}
					timeStamp = (float)clock() / CLOCKS_PER_SEC;
					// Calculate dT=t1-t0
					if (timeStamp - stageTime0 > DURATION_D0)
					{
						// Wrong alarm, back to cMotion stage
						stage = STAGE_CMOTION;
					}
					break;
				case STAGE_DY:
					if (_calElipseParams(rotatedRect, contours[theLargestId], angle1, a_b1))
					{
						center1 = rotatedRect.center;
					}
					cout << center1 << endl;
					rectangle(frame, boundingRect(contours[theLargestId]), Scalar(0, 0, 255), 4);
					if (sumHist / humanArea < THRESHOLD_CMOTION_DY && abs(center1.x - center0.x) < THRESHOLD_DX && abs(center1.y - center0.y) < THRESHOLD_DY)
					{
						// Send notification
						cout << "\a" << endl;
						stage = STAGE_CMOTION;
					}
					center0 = center1;
					timeStamp = (float)clock() / CLOCKS_PER_SEC;
					// Calculate dT=t1-t0
					if (timeStamp - stageTime0 > DURATION_DY)
					{
						// Wrong alarm, back to cMotion stage
						stage = STAGE_CMOTION;
					}
					break;
				default:
					stage = STAGE_CMOTION;
				}
			}
		}

		//Display
		imshow("Shadow_Removed", binaryImg);
		imshow("Blur_Resize", frame);
		imshow("MHI", mhiDst);

		if (waitKey(5) >= 0)
			break;
	}
}